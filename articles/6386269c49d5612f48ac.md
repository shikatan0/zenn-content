---
title: "Windows - F# ã¨æ¨™æº–æ©Ÿèƒ½ã§é¸æŠé ˜åŸŸã® OCR"
emoji: "ğŸ”"
type: "tech"
topics: ["windows", "fsharp"]
published: true
---

# æ¦‚è¦

ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆæ’®å½±ã‚¢ãƒ—ãƒªã€Œåˆ‡ã‚Šå–ã‚Šï¼†ã‚¹ã‚±ãƒƒãƒ[^1]ã€ã¨ã€ŒWindows.Media.Ocr[^2]ã€ã‚’çµ„ã¿åˆã‚ã›ã¦ã€é¸æŠã—ãŸé ˜åŸŸã®ãƒ†ã‚­ã‚¹ãƒˆã‚’èª­ã¿å–ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’ F# ã§ä½œã‚‹ã€‚

å½¢å¼ã¨ã—ã¦ã¯ã€é ˜åŸŸã®é¸æŠã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼ã§é–‹å§‹ã—ã€èª­ã¿å–ã£ãŸãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ä¿å­˜ã™ã‚‹ã€ã‚¿ã‚¹ã‚¯ãƒˆãƒ¬ã‚¤å¸¸é§å‹ã®ã‚¢ãƒ—ãƒªã¨ã—ã¾ã—ãŸã€‚

[^1]: ã€ŒWindows 10 October 2018 Updateã€ã«ã¦æ¨™æº–æ­è¼‰ã€‚
[^2]: ã€ŒWindows 10ã€ã«ã¦æ¨™æº–æ­è¼‰ã€‚

# ä½œæˆç’°å¢ƒ

|å¯¾è±¡|ãƒãƒ¼ã‚¸ãƒ§ãƒ³|
|:-:|:-:|
|Windows|20H2 (19042.928)|
|.NET SDK|5.0.202|

# å®Ÿè£…ä¾‹

â€»ã€Œåˆ‡ã‚Šå–ã‚Šï¼†ã‚¹ã‚±ãƒƒãƒã€ã®è¨­å®šã€Œã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«è‡ªå‹•ã‚³ãƒ”ãƒ¼ã€ã‚’ã‚ªãƒ³ã«ã™ã‚‹ã€‚

```xml:.fsproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net5.0-windows10.0.19041.0</TargetFramework>
    <RootNamespace>ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå</RootNamespace>
    <UseWindowsForms>true</UseWindowsForms>
    <UseWPF>true</UseWPF>
  </PropertyGroup>

  <ItemGroup>
    <Compile Include="Program.fs" />
  </ItemGroup>

</Project>

```

```fsharp:Program.fs
open System

let await (i: Windows.Foundation.IAsyncOperation<'TResult>) =
    i.AsTask() |> Async.AwaitTask


let startScreenclip () =
    let cmd = new System.Diagnostics.ProcessStartInfo "cmd"
    cmd.Arguments <- @"/c start ms-screenclip:"
    cmd.UseShellExecute <- true
    cmd.WindowStyle <- System.Diagnostics.ProcessWindowStyle.Hidden

    let cmdProcess = System.Diagnostics.Process.Start cmd
    cmdProcess.WaitForExit()

    let processArray = System.Diagnostics.Process.GetProcessesByName "ScreenClippingHost"
    processArray.[0].WaitForExit()


let getClipboardBitmap () =
    let bitmapSource = System.Windows.Clipboard.GetImage()

    if bitmapSource <> null then
        let bitmapFrame = System.Windows.Media.Imaging.BitmapFrame.Create bitmapSource

        let encoder = new System.Windows.Media.Imaging.BmpBitmapEncoder()
        encoder.Frames.Add bitmapFrame

        use memoryStream = new System.IO.MemoryStream()
        encoder.Save memoryStream

        let byteArray = memoryStream.ToArray()

        use randomAccessStream = new Windows.Storage.Streams.InMemoryRandomAccessStream()
        use outputStream = randomAccessStream.GetOutputStreamAt(uint64 0)
        use dataWriter = new Windows.Storage.Streams.DataWriter(outputStream)
        dataWriter.WriteBytes byteArray

        async {
            let! _ = await <| dataWriter.StoreAsync()
            let! _ = await <| outputStream.FlushAsync()

            let! decoder = await <| Windows.Graphics.Imaging.BitmapDecoder.CreateAsync randomAccessStream
            let! softwareBitmap = await <| decoder.GetSoftwareBitmapAsync(Windows.Graphics.Imaging.BitmapPixelFormat.Bgra8, Windows.Graphics.Imaging.BitmapAlphaMode.Premultiplied)

            return softwareBitmap
        }
        |> Async.RunSynchronously
    else
        null


let startOCR bitmap =
    let ocrEngine = Windows.Media.Ocr.OcrEngine.TryCreateFromUserProfileLanguages()

    if bitmap <> null then
        async {
            let! ocrResult = await <| ocrEngine.RecognizeAsync bitmap
            return ocrResult.Text
        }
        |> Async.RunSynchronously
    else
        ""


let createIcon () =
    let toolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem(Text = "&çµ‚äº†")
    toolStripMenuItem.Click.Add(fun e -> System.Windows.Forms.Application.Exit())

    let contextMenuStrip = new System.Windows.Forms.ContextMenuStrip()
    contextMenuStrip.Items.Add toolStripMenuItem |> ignore

    new System.Windows.Forms.NotifyIcon(
        Icon = new System.Drawing.Icon @".\icon.ico",
        Visible = true,
        Text = "TestApp",
        ContextMenuStrip = contextMenuStrip
    )


[<System.Runtime.InteropServices.DllImport("user32.dll")>]
extern int RegisterHotKey(IntPtr HWnd, int ID, int MOD_KEY, int KEY)

[<System.Runtime.InteropServices.DllImport("user32.dll")>]
extern int UnregisterHotKey(IntPtr HWnd, int ID)


type HotkeyForm () as this =
    inherit System.Windows.Forms.Form()

    let icon = createIcon()

    do
        RegisterHotKey(this.Handle, 0x0000, 0x0001 ||| 0x0008, int System.Windows.Forms.Keys.C) |> ignore

        System.Windows.Forms.Application.ApplicationExit.Add(fun e ->
            UnregisterHotKey(this.Handle, 0x0000) |> ignore
        )

    override this.WndProc m =
        base.WndProc(&m)

        if m.Msg = 0x0312 && int m.WParam = 0x0000 then
            startScreenclip()
            System.Windows.Clipboard.SetText(startOCR <| getClipboardBitmap())

    interface IDisposable with
        member this.Dispose() =
            icon.Dispose()


[<STAThread>]
do
    use form = new HotkeyForm()
    System.Windows.Forms.Application.Run()
```

# è§£èª¬

## åˆ‡ã‚Šå–ã‚Šï¼†ã‚¹ã‚±ãƒƒãƒ

ã€Œåˆ‡ã‚Šå–ã‚Šï¼†ã‚¹ã‚±ãƒƒãƒã€ã®ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«é¸æŠé ˜åŸŸã®ç”»åƒã‚’ä¿å­˜ã™ã‚‹æ©Ÿèƒ½ã‚’åˆ©ç”¨ã™ã‚‹ã€‚

```fsharp
let startScreenclip () =

    // ã‚³ãƒãƒ³ãƒ‰ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ
    let cmd = new System.Diagnostics.ProcessStartInfo "cmd"

    // ã€Œms-screenclip:ã€æ–°è¦åˆ‡ã‚Šå–ã‚Šã‚’é–‹å§‹ã™ã‚‹ URI ã‚¹ã‚­ãƒ¼ãƒ 
    cmd.Arguments <- @"/c start ms-screenclip:"

    cmd.UseShellExecute <- true
    cmd.WindowStyle <- System.Diagnostics.ProcessWindowStyle.Hidden

    // ã€Œåˆ‡ã‚Šå–ã‚Šï¼†ã‚¹ã‚±ãƒƒãƒã€ã®èµ·å‹•
    let cmdProcess = System.Diagnostics.Process.Start cmd
    cmdProcess.WaitForExit()

    // ã€Œåˆ‡ã‚Šå–ã‚Šï¼†ã‚¹ã‚±ãƒƒãƒã€ã®çµ‚äº†å¾…æ©Ÿ
    let processArray = System.Diagnostics.Process.GetProcessesByName "ScreenClippingHost"
    processArray.[0].WaitForExit()
```

## ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‹ã‚‰ç”»åƒã‚’å–å¾—ã™ã‚‹

```fsharp
let getClipboardBitmap () =

    // WPF ã®æ©Ÿèƒ½ã‚’åˆ©ç”¨

    let bitmapSource = System.Windows.Clipboard.GetImage()

    if bitmapSource <> null then

        // ä»¥ä¸‹ã€ŒWindows.Media.Ocrã€ãŒèªè­˜ã§ãã‚‹ SoftwareBitmap ã«å¤‰æ›ã™ã‚‹å‡¦ç†

        let bitmapFrame = System.Windows.Media.Imaging.BitmapFrame.Create bitmapSource

        let encoder = new System.Windows.Media.Imaging.BmpBitmapEncoder()
        encoder.Frames.Add bitmapFrame

        use memoryStream = new System.IO.MemoryStream()
        encoder.Save memoryStream

        let byteArray = memoryStream.ToArray()

        use randomAccessStream = new  Windows.Storage.Streams.InMemoryRandomAccessStream()
        use outputStream = randomAccessStream.GetOutputStreamAt(uint64 0)
        use dataWriter = new Windows.Storage.Streams.DataWriter(outputStream)
        dataWriter.WriteBytes byteArray

        async {
            let! _ = await <| dataWriter.StoreAsync()
            let! _ = await <| outputStream.FlushAsync()

            let! decoder = await <| Windows.Graphics.Imaging.BitmapDecoder.CreateAsync randomAccessStream
            let! softwareBitmap = await <| decoder.GetSoftwareBitmapAsync(Windows.Graphics.Imaging.BitmapPixelFormat.Bgra8, Windows.Graphics.Imaging.BitmapAlphaMode.Premultiplied)

            return softwareBitmap
        }
        |> Async.RunSynchronously
    else
        null
```

## Windows.Media.Ocr

https://zenn.dev/shikatan/articles/451245de0f5dd70d28be

## ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒ›ãƒƒãƒˆã‚­ãƒ¼

https://zenn.dev/shikatan/articles/f6c4c52c134b61

# æ›´æ–°å±¥æ­´

|æ—¥ä»˜|å†…å®¹|
|:-:|:-:|
|2021/04/26|ã€Œåˆ‡ã‚Šå–ã‚Šï¼†ã‚¹ã‚±ãƒƒãƒã€ã«é–¢ã™ã‚‹å†…å®¹ã‚’è¿½åŠ ã€‚|

# end
